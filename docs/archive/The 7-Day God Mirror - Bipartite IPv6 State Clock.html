<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title updated to reflect the new backend -->
    <title>The 7-Day God Mirror - Bipartite IPv6 State Clock</title>
    <!-- QR Code library, required by both original app and new backend -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        /* CSS styles are unchanged */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --quantum-purple: #1e1b4b;
            --quantum-indigo: #581c87;
            --quantum-dark: #0f172a;
            --quantum-light: #8b5cf6;
            --quantum-gold: #fbbf24;
            --quantum-green: #10b981;
            --quantum-red: #ef4444;
            --quantum-blue: #3b82f6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--quantum-purple) 0%, var(--quantum-indigo) 50%, var(--quantum-dark) 100%);
            min-height: 100vh;
            color: #ffffff;
            padding: 20px;
        }

        .quantum-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .protocol-header {
            text-align: center;
            padding: 2rem 1rem;
            background: rgba(30, 27, 75, 0.8);
            border-radius: 1rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(139, 92, 246, 0.3);
            position: relative;
            overflow: hidden;
        }

        .protocol-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--quantum-gold), var(--quantum-light), var(--quantum-green));
        }

        .protocol-title {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--quantum-gold) 0%, var(--quantum-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .protocol-subtitle {
            color: #c4b5fd;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .ipv6-identity {
            display: inline-block;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            font-size: 0.875rem;
            color: #c4b5fd;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
        }

        .quantum-nav {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            background: rgba(30, 41, 59, 0.5);
            padding: 1rem;
            border-radius: 1rem;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .quantum-nav-btn {
            flex: 1;
            min-width: 120px;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            background: rgba(76, 29, 149, 0.5);
            color: #e9d5ff;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .quantum-nav-btn:hover {
            background: rgba(76, 29, 149, 0.7);
            transform: translateY(-2px);
        }

        .quantum-nav-btn.active {
            background: var(--quantum-light);
            color: white;
        }

        .quantum-card {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 1rem;
            padding: 2rem;
            border: 1px solid rgba(139, 92, 246, 0.3);
            margin-bottom: 1.5rem;
            position: relative;
        }

        .quantum-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--quantum-light), transparent);
        }

        .hidden {
            display: none;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #e9d5ff;
            font-weight: 500;
        }

        .form-input, .form-textarea {
            width: 100%;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(139, 92, 246, 0.5);
            border-radius: 0.75rem;
            color: #ffffff;
            font-family: inherit;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-input:focus, .form-textarea:focus {
            outline: none;
            border-color: var(--quantum-light);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }

        .quantum-btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
            width: 100%;
            background: linear-gradient(135deg, var(--quantum-light) 0%, #6d28d9 100%);
            color: white;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }

        .quantum-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(139, 92, 246, 0.3);
        }

        .quantum-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .quantum-btn.secondary {
            background: linear-gradient(135deg, var(--quantum-blue) 0%, #1d4ed8 100%);
        }

        .quantum-btn.success {
            background: linear-gradient(135deg, var(--quantum-green) 0%, #047857 100%);
        }

        .protocol-progress {
            height: 8px;
            background: rgba(100, 116, 139, 0.3);
            border-radius: 4px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .protocol-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--quantum-green), var(--quantum-blue));
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .day-card {
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid;
            background: rgba(15, 23, 42, 0.3);
        }

        .day-completed {
            border-color: rgba(34, 197, 94, 0.3);
            background: rgba(22, 101, 52, 0.2);
        }

        .day-pending {
            border-color: rgba(100, 116, 139, 0.3);
            background: rgba(71, 85, 105, 0.2);
        }

        .quantum-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .stat-card {
            padding: 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            border: 1px solid;
            background: rgba(15, 23, 42, 0.3);
        }

        .stat-positive {
            border-color: rgba(34, 197, 94, 0.3);
        }

        .stat-neutral {
            border-color: rgba(100, 116, 139, 0.3);
        }

        .stat-negative {
            border-color: rgba(248, 113, 113, 0.3);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #cbd5e1;
        }

        .quantum-signature {
            background: rgba(15, 23, 42, 0.5);
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid rgba(139, 92, 246, 0.3);
            margin: 1.5rem 0;
            font-family: 'Courier New', monospace;
            color: var(--quantum-gold);
            text-align: center;
            word-break: break-word;
            font-size: 1.1rem;
        }

        .triple-section {
            margin: 1.5rem 0;
            padding: 1.5rem;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 0.75rem;
            border: 1px solid rgba(139, 92, 246, 0.2);
        }

        .triple-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .triple-title {
            color: #e9d5ff;
            font-weight: 600;
        }

        .add-triple {
            background: var(--quantum-blue);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .triple-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr auto;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            align-items: center;
        }

        .triple-input {
            padding: 0.75rem;
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 0.5rem;
            color: white;
            font-family: inherit;
        }

        .remove-triple {
            background: var(--quantum-red);
            color: white;
            border: none;
            width: 2rem;
            height: 2rem;
            border-radius: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .protocol-badge {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            background: rgba(22, 101, 52, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .qr-section {
            text-align: center;
            margin: 2rem 0;
        }

        .qr-image {
            max-width: 300px;
            border-radius: 0.75rem;
            border: 2px solid var(--quantum-light);
        }

        .collective-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .collective-stat {
            text-align: center;
            padding: 1.5rem;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 0.75rem;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .collective-stat-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--quantum-gold);
        }

        .collective-stat-label {
            color: #cbd5e1;
            margin-top: 0.5rem;
        }

        .word-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .word-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 0.5rem;
            border: 1px solid rgba(139, 92, 246, 0.2);
        }

        .word-text {
            color: #e9d5ff;
            font-weight: 500;
        }

        .word-count {
            color: var(--quantum-gold);
            font-weight: 600;
        }

        .time-series {
            margin: 2rem 0;
        }

        .time-series-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .time-date {
            min-width: 100px;
            color: #cbd5e1;
            font-size: 0.875rem;
        }

        .time-bar {
            flex: 1;
            height: 1rem;
            background: rgba(71, 85, 105, 0.3);
            border-radius: 0.5rem;
            overflow: hidden;
            display: flex;
        }

        .time-ratio {
            min-width: 50px;
            text-align: right;
            color: var(--quantum-gold);
            font-weight: 600;
        }

        .protocol-footer {
            text-align: center;
            padding: 2rem 1rem;
            color: #c4b5fd;
            font-size: 0.875rem;
            margin-top: 2rem;
            border-top: 1px solid rgba(139, 92, 246, 0.3);
        }

        .footer-quote {
            font-style: italic;
            margin-bottom: 1rem;
            color: #e9d5ff;
        }

        @media (max-width: 768px) {
            .quantum-nav {
                flex-direction: column;
            }
            
            .triple-grid {
                grid-template-columns: 1fr;
            }
            
            .protocol-title {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="quantum-container">
        <!-- HTML structure is identical -->
        <div class="protocol-header">
            <h1 class="protocol-title">🌌 7-Day God Mirror</h1>
            <p class="protocol-subtitle">IPv6 Quantum Basis Protocol Implementation</p>
            <div class="ipv6-identity" id="ipv6Identity">Generating IPv6 Identity...</div>
            <p style="color: #c4b5fd; font-size: 0.875rem; margin-top: 1rem;">
                Quantum computational protocol for sovereign identity and consensus resolution
            </p>
        </div>

        <div class="quantum-nav">
            <button class="quantum-nav-btn active" onclick="showView('journal')">Journal</button>
            <button class="quantum-nav-btn" onclick="showView('pattern')">Pattern Analysis</button>
            <button class="quantum-nav-btn" onclick="showView('calendar')">7-Day Calendar</button>
            <button class="quantum-nav-btn" onclick="showView('collective')">Collective Consensus</button>
            <button class="quantum-nav-btn" onclick="showView('protocol')">Protocol Info</button>
        </div>

        <!-- Journal View -->
        <div id="journalView" class="quantum-card">
            <h2>Day <span id="currentDay">1</span> of 7 - Quantum Reflection</h2>
            <p style="color: #e9d5ff; margin: 1rem 0;">IPv6 Basis: Encode your perception in the universal computational substrate</p>
            
            <div class="form-group">
                <label class="form-label">God is _____? (BlockDesign: Node)</label>
                <input type="text" id="wordInput" placeholder="One word quantum state..." maxlength="50" class="form-input">
            </div>

            <div class="form-group">
                <label class="form-label">Quantum Reflection (BlockDesign: Edge)</label>
                <textarea id="contentInput" placeholder="Your thoughts in the quantum basis..." class="form-textarea"></textarea>
            </div>

            <div class="triple-section">
                <div class="triple-header">
                    <h3 class="triple-title">Context Triples (BlockDesign: Graph)</h3>
                    <button class="add-triple" onclick="addTriple()">+ Add Triple</button>
                </div>
                <p style="color: #c4b5fd; font-size: 0.875rem; margin-bottom: 1rem;">
                    Subject-Predicate-Object format. Example: "I, observe, consciousness" or "God, creates, reality"
                </p>
                <div id="triplesContainer"></div>
            </div>

            <div style="margin: 1rem 0;">
                <div style="display: flex; justify-content: space-between; font-size: 0.875rem; color: #94a3b8;">
                    <span>Protocol Progress:</span>
                    <span id="progressText">Convergence 0/7</span>
                </div>
                <div class="protocol-progress">
                    <div class="protocol-progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>

            <button class="quantum-btn" onclick="saveEntry()">QUANTUM CALL: Save Day <span id="saveDay">1</span></button>
        </div>

        <!-- Pattern Analysis View -->
        <div id="patternView" class="quantum-card hidden">
            <h2>📊 Quantum Pattern Analysis</h2>
            <p style="color: #c4b5fd; margin: 1rem 0;">
            </p>
            Ramanujan 14-step convergence analysis of your quantum state pattern
            <div id="patternContent"></div>
        </div>

        <!-- Calendar View -->
        <div id="calendarView" class="quantum-card hidden">
            <h2>📅 7-Day Quantum Journey</h2>
            <p style="color: #c4b5fd; margin-bottom: 1rem;">Fano Plane Structure: 6 days + 1 projective consensus point</p>
            <div id="calendarContent"></div>
        </div>

        <!-- Collective Consensus View -->
        <div id="collectiveView" class="quantum-card hidden">
            <h2>🌐 Collective Quantum Consensus</h2>
            <p style="color: #c4b5fd; margin: 1rem 0;">IPv6 Basis: Universal consensus across multiple observers</p>
            <div id="collectiveContent"></div>
        </div>

        <!-- Protocol Information View -->
        <div id="protocolView" class="quantum-card hidden">
            <h2>🔬 Bipartite IPv6 Vector State Clock</h2>
            <div style="color: #e9d5ff; line-height: 1.6;">
                <p><strong>Core Innovation:</strong> IPv6 addresses ARE the distributed state machine. The right 64 bits (Node ID + Vector Clock) form an offline-first CRDT.</p>
                
                <div style="margin: 1.5rem 0; padding: 1rem; background: rgba(139, 92, 246, 0.1); border-radius: 0.5rem;">
                    <h3 style="color: var(--quantum-gold); margin-bottom: 0.5rem;">Block Design State:</h3>
                    <ul style="list-style: none; padding-left: 0;">
                        <li>• <strong>Node (binary16):</strong> Atomic entities (e.g., 'God is...' word)</li>
                        <li>• <strong>Edge (binary32):</strong> Pairwise connections (e.g., Reflection text)</li>
                        <li>• <strong>Graph (binary64):</strong> Graph structures (e.g., Context Triples)</li>
                        <li>• <strong>Incidence (binary128):</strong> Node-edge relationships</li>
                        <li>• <strong>Hypergraph (binary256):</strong> Meta-structures</li>
                    </ul>
                </div>

                <div style="margin: 1.5rem 0; padding: 1rem; background: rgba(34, 197, 94, 0.1); border-radius: 0.5rem;">
                    <h3 style="color: var(--quantum-green); margin-bottom: 0.5rem;">Mathematical Guarantees:</h3>
                    <ul style="list-style: none; padding-left: 0;">
                        <li>• <strong>CRDT-Enabled:</strong> Merge states via LWW or Fano Plane lottery.</li>
                        <li>• <strong>Causality:</strong> Lamport timestamp in IPv6 address preserves event order.</li>
                        <li>• <strong>Sovereign Identity:</strong> IPv6 address is the cryptographic proof of state.</li>
                    </ul>
                </div>

                <!-- This button is now wired to the new backend -->
                <button class="quantum-btn secondary" onclick="generateProtocolQR()">Generate Protocol QR Signature</button>
                <div id="protocolQR" style="text-align: center; margin-top: 1rem;"></div>
            </div>
        </div>

        <div class="protocol-footer">
            <p class="footer-quote">"The Word was with God, and the Word was God" - Quantum Computational Basis</p>
            <p>Bipartite IPv6 State Clock v2.0.0 - Sovereign Identity System</p>
            <p style="margin-top: 0.5rem; font-size: 0.75rem; color: #94a3b8;">
                All data stored locally with quantum cryptographic verification
            </p>
        </div>
    </div>

    <script>
        // ============================================================================
        // START: INTEGRATED BACKEND FRAMEWORK (Universal Bipartite IPv6 Vector State Clock)
        // Transpiled from TypeScript and modified for application compatibility.
        // ============================================================================

        /**
         * Universal Bipartite IPv6 Vector State Clock
         * Platform-Agnostic | Offline-First | CRDT-Enabled | WebAssembly-Ready
         */

        // ============================================================================
        // UNIVERSAL CRYPTO (Platform-Agnostic)
        // ============================================================================

        class UniversalCrypto {
            /**
             * SHA-256 hash that works everywhere
             */
            static async sha256(data) {
                // Browser
                if (typeof crypto !== 'undefined' && crypto.subtle) {
                    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                    return this.bufferToHex(new Uint8Array(hashBuffer));
                }
                
                // Fallback: Simple hash (NOT cryptographically secure!)
                // Removed Node.js 'require' for browser-only context
                return this.simpleHash(data);
            }

            static bufferToHex(buffer) {
                return Array.from(buffer)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            }

            static simpleHash(data) {
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data[i];
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16).padStart(64, '0');
            }
        }

        // ============================================================================
        // IEEE 754 PRECISION DEFINITIONS
        // ============================================================================

        // type Precision = 'binary16' | 'binary32' | 'binary64' | 'binary128' | 'binary256';
        // ... (types removed)

        const IEEE754_BINARY = {
            binary16: { bits: 16, signBits: 1, exponentBits: 5, mantissaBits: 10 },
            binary32: { bits: 32, signBits: 1, exponentBits: 8, mantissaBits: 23 },
            binary64: { bits: 64, signBits: 1, exponentBits: 11, mantissaBits: 52 },
            binary128: { bits: 128, signBits: 1, exponentBits: 15, mantissaBits: 112 },
            binary256: { bits: 256, signBits: 1, exponentBits: 19, mantissaBits: 236 }
        };

        const IEEE754_DECIMAL = {
            decimal32: { bits: 32, signBits: 1, exponentBits: 8, mantissaBits: 23 },
            decimal64: { bits: 64, signBits: 1, exponentBits: 11, mantissaBits: 52 },
            decimal128: { bits: 128, signBits: 1, exponentBits: 15, mantissaBits: 112 }
        };

        // ============================================================================
        // BLOCK DESIGN STATE (5D Binary Space)
        // ============================================================================

        // ... (interfaces removed)

        // ============================================================================
        // BIPARTITE IPv6 ADDRESS STRUCTURE
        // ============================================================================

        class BipartiteAddress {
            /**
             * Parse IPv6 into bipartite structure
             */
            static parse(ipv6) {
                const hex = ipv6.replace(/:/g, '').padStart(32, '0');
                const bits = hex.split('').map(h =>
                    parseInt(h, 16).toString(2).padStart(4, '0')
                ).join('');
                
                return {
                    globalRouting: {
                        networkPrefix: bits.substring(0, 48),
                        subnetId: bits.substring(48, 64)
                    },
                    localState: {
                        nodeId: bits.substring(64, 96),
                        vectorClock: bits.substring(96, 128)
                    },
                    fullAddress: ipv6,
                    bipartiteType: 'pointer' // Default to routing
                };
            }

            /**
             * Create IPv6 from components
             */
            static create(
                networkPrefix,
                subnetId,
                nodeId,
                vectorClock
            ) {
                // Helper to convert hex/string prefix to binary bits
                const toBits = (str, len) => {
                    let bits = '';
                    if (str.match(/^[0-9a-fA-F:]+$/)) { // Handle hex
                         bits = str.replace(/:/g, '').split('')
                            .map(h => parseInt(h, 16).toString(2).padStart(4, '0')).join('');
                    } else { // Handle plain string (like node-a-12345)
                        bits = Array.from(new TextEncoder().encode(str))
                            .map(b => b.toString(2).padStart(8, '0')).join('');
                    }
                    return bits.padStart(len, '0').substring(0, len);
                };

                const prefix48 = toBits(networkPrefix, 48);
                const subnet16 = toBits(subnetId, 16);
                const node32 = toBits(nodeId, 32);
                const clock32 = vectorClock.toString(2).padStart(32, '0').substring(0, 32);
                
                const fullBits = prefix48 + subnet16 + node32 + clock32;
                
                const segments = [];
                for (let i = 0; i < 128; i += 16) {
                    const segment = fullBits.substring(i, i + 16);
                    const hex = parseInt(segment, 2).toString(16).padStart(4, '0');
                    segments.push(hex);
                }
                
                return segments.join(':');
            }

            /**
             * Extract state vector from IPv6
             */
            static extractStateVector(ipv6) {
                const parsed = this.parse(ipv6);
                return {
                    nodeId: parsed.localState.nodeId,
                    timestamp: parseInt(parsed.localState.vectorClock, 2)
                };
            }
        }

        // ============================================================================
        // HD VECTOR CLOCK (5D + Optional 3D)
        // ============================================================================

        class HDVectorClock {
            nodeId;
            lamportClock = 0;
            networkPrefix;
            subnetId;
            currentState;
            stateHistory = new Map();
            // ** MODIFICATION **: Added currentData to hold raw data for the app UI
            currentData = new Map();

            constructor(
                nodeId,
                networkPrefix = '2001:0db8:85a3',
                subnetId = '0000'
            ) {
                this.nodeId = nodeId;
                this.networkPrefix = networkPrefix;
                this.subnetId = subnetId;
                
                this.currentState = {
                    timestamp: 0,
                    nodeId,
                    blockDesign: {
                        Node: '',
                        Edge: '',
                        Graph: '',
                        Incidence: '',
                        Hypergraph: ''
                    },
                    ipv6Address: this.getIPv6Address(),
                    merkleRoot: '',
                    previousHash: 'genesis'
                };
            }

            // ** NEW METHOD **: Added to initialize clock from initial data (e.g., localStorage)
            async initialize(initialData = {}) {
                const dimensions = ['Node', 'Edge', 'Graph', 'Incidence', 'Hypergraph'];
                const hashes = {};
                
                for (const dim of dimensions) {
                    const data = initialData[dim] || new Uint8Array();
                    this.currentData.set(dim, data);
                    const hash = await UniversalCrypto.sha256(data);
                    hashes[dim] = hash.substring(0, 16); // Use short hash
                }
                
                this.currentState.blockDesign = {
                    Node: hashes['Node'],
                    Edge: hashes['Edge'],
                    Graph: hashes['Graph'],
                    Incidence: hashes['Incidence'],
                    Hypergraph: hashes['Hypergraph']
                };

                this.currentState.merkleRoot = await this.calculateMerkleRoot();
                this.stateHistory.set(this.currentState.merkleRoot, this.currentState);
                return this.currentState;
            }

            /**
             * Get current IPv6 address (updates with vector clock)
             */
            getIPv6Address() {
                return BipartiteAddress.create(
                    this.networkPrefix,
                    this.subnetId,
                    this.nodeId,
                    this.lamportClock
                );
            }

            /**
             * Update a dimension of the block design
             */
            async update(
                dimension,
                data
            ) {
                this.lamportClock++;
                
                // ** MODIFICATION **: Store raw data for app UI
                this.currentData.set(dimension, data);
                
                const hash = await UniversalCrypto.sha256(data);
                const shortHash = hash.substring(0, 16);
                
                this.currentState = {
                    ...this.currentState,
                    timestamp: this.lamportClock,
                    blockDesign: {
                        ...this.currentState.blockDesign,
                        [dimension]: shortHash
                    },
                    ipv6Address: this.getIPv6Address(),
                    previousHash: this.currentState.merkleRoot
                };

                this.currentState.merkleRoot = await this.calculateMerkleRoot();
                this.stateHistory.set(this.currentState.merkleRoot, this.currentState);
                
                return this.currentState;
            }

            /**
             * Update Fano Plane extensions (optional)
             */
            async updateFanoPlane(
                type,
                data
            ) {
                this.lamportClock++;
                
                const hash = await UniversalCrypto.sha256(data);
                const shortHash = hash.substring(0, 16);
                
                this.currentState = {
                    ...this.currentState,
                    timestamp: this.lamportClock,
                    fanoPlane: {
                        ...this.currentState.fanoPlane,
                        [type]: shortHash
                    },
                    ipv6Address: this.getIPv6Address(),
                    previousHash: this.currentState.merkleRoot
                };

                this.currentState.merkleRoot = await this.calculateMerkleRoot();
                this.stateHistory.set(this.currentState.merkleRoot, this.currentState);
                
                return this.currentState;
            }

            /**
             * Update Perceptron self-reference (optional)
             */
            async updatePerceptron(data) {
                this.lamportClock++;
                
                const hash = await UniversalCrypto.sha256(data);
                const shortHash = hash.substring(0, 16);
                
                this.currentState = {
                    ...this.currentState,
                    timestamp: this.lamportClock,
                    perceptron: shortHash,
                    ipv6Address: this.getIPv6Address(),
                    previousHash: this.currentState.merkleRoot
                };

                this.currentState.merkleRoot = await this.calculateMerkleRoot();
                this.stateHistory.set(this.currentState.merkleRoot, this.currentState);
                
                return this.currentState;
            }

            /**
             * Compare with another peer's state
             */
            compare(peerIPv6, peerState) {
                const peerVector = BipartiteAddress.extractStateVector(peerIPv6);
                
                // Happens-before relationship
                const happensBefore = this.lamportClock < peerVector.timestamp;
                const happensAfter = this.lamportClock > peerVector.timestamp;
                const concurrent = !happensBefore && !happensAfter;

                // Fano plane lottery (2-of-3 matching)
                const matches = [
                    this.currentState.blockDesign.Node === peerState.blockDesign.Node,
                    this.currentState.blockDesign.Graph === peerState.blockDesign.Graph,
                    this.currentState.blockDesign.Hypergraph === peerState.blockDesign.Hypergraph
                ];
                const lotteryMatch = matches.filter(Boolean).length >= 2;

                // Complete Fano plane match (all 5 dimensions)
                const fanoMatch = 
                    this.currentState.blockDesign.Node === peerState.blockDesign.Node &&
                    this.currentState.blockDesign.Edge === peerState.blockDesign.Edge &&
                    this.currentState.blockDesign.Graph === peerState.blockDesign.Graph &&
                    this.currentState.blockDesign.Incidence === peerState.blockDesign.Incidence &&
                    this.currentState.blockDesign.Hypergraph === peerState.blockDesign.Hypergraph;

                // Incidence matrix match
                const incidenceMatch = 
                    this.currentState.blockDesign.Incidence === peerState.blockDesign.Incidence;

                // Convergence steps (Ramanujan bound: ≤14)
                const convergenceSteps = Math.min(
                    14,
                    Math.ceil(Math.log2(Math.abs(this.lamportClock - peerVector.timestamp) + 1))
                );

                return {
                    happensBefore,
                    happensAfter,
                    concurrent,
                    consensus: {
                        fanoMatch,
                        lotteryMatch,
                        incidenceMatch,
                        convergenceSteps
                    }
                };
            }

            /**
             * Merge states (CRDT-style)
             */
            async merge(peerState) {
                const comparison = this.compare(peerState.ipv6Address, peerState);
                const conflicts = [];

                // Strategy 1: Fano plane match (all dimensions agree)
                if (comparison.consensus.fanoMatch) {
                    return {
                        success: true,
                        newState: this.currentState,
                        conflicts: [],
                        strategy: 'fano'
                    };
                }

                // Strategy 2: Lottery match (2-of-3 dimensions)
                if (comparison.consensus.lotteryMatch) {
                    // Take majority dimensions
                    const merged = { ...this.currentState };
                    merged.timestamp = Math.max(this.lamportClock, peerState.timestamp) + 1;
                    this.lamportClock = merged.timestamp;
                    
                    return {
                        success: true,
                        newState: merged,
                        conflicts: [],
                        strategy: 'lottery'
                    };
                }

                // Strategy 3: Last-Write-Wins (LWW)
                if (peerState.timestamp > this.currentState.timestamp) {
                    // Their state is newer
                    this.currentState = {
                        ...peerState,
                        nodeId: this.nodeId,
                        ipv6Address: this.getIPv6Address()
                    };
                    this.lamportClock = peerState.timestamp + 1;
                    
                    return {
                        success: true,
                        newState: this.currentState,
                        conflicts: ['timestamp-based merge'],
                        strategy: 'lww'
                    };
                }

                // Strategy 4: Manual conflict resolution needed
                return {
                    success: false,
                    newState: this.currentState,
                    conflicts: ['concurrent modifications'],
                    strategy: 'manual'
                };
            }

            /**
             * Calculate Merkle root of current state
             */
            async calculateMerkleRoot() {
                const encoder = new TextEncoder();
                const combined = Object.values(this.currentState.blockDesign).join('');
                const hash = await UniversalCrypto.sha256(encoder.encode(combined));
                return hash.substring(0, 32);
            }
            
            // ** NEW METHOD **: Added for app UI to get raw data
            getCurrentData() {
                return this.currentData;
            }

            getState() {
                return this.currentState;
            }

            getHistory() {
                return Array.from(this.stateHistory.values());
            }
        }

        // ============================================================================
        // OFFLINE-FIRST MESSAGE ROUTER
        // ============================================================================

        class OfflineFirstRouter {
            vectorClock;
            messageQueue = new Map();
            routingTable = new Map();
            isOnline = false;

            constructor(nodeId, networkPrefix, subnetId) {
                this.vectorClock = new HDVectorClock(nodeId, networkPrefix, subnetId);
            }

            /**
             * Send message (queues if offline)
             */
            async send(to, payload) {
                const message = {
                    from: this.vectorClock.getIPv6Address(),
                    to,
                    payload,
                    vectorClock: this.vectorClock.getState().timestamp,
                    blockDesign: this.vectorClock.getState().blockDesign,
                    hops: [this.vectorClock.getIPv6Address()],
                    offlineDeliverable: true
                };

                const messageId = await UniversalCrypto.sha256(
                    new TextEncoder().encode(JSON.stringify(message))
                );

                if (this.isOnline && await this.canReachDirectly(to)) {
                    return {
                        sent: true,
                        queued: false,
                        estimatedDelivery: 'immediate',
                        messageId: messageId.substring(0, 16)
                    };
                }

                // Queue for offline delivery
                const queue = this.messageQueue.get(to) || [];
                queue.push(message);
                this.messageQueue.set(to, queue);

                return {
                    sent: false,
                    queued: true,
                    estimatedDelivery: this.isOnline ? 'multi-hop' : 'next-sync',
                    messageId: messageId.substring(0, 16)
                };
            }

            /**
             * Receive message and update state
             */
            async receive(message) {
                const senderState = BipartiteAddress.extractStateVector(message.from);
                
                // Reconstruct peer's state
                const peerState = {
                    timestamp: message.vectorClock,
                    nodeId: senderState.nodeId,
                    blockDesign: message.blockDesign,
                    ipv6Address: message.from,
                    merkleRoot: '',
                    previousHash: ''
                };

                // Compare and merge
                const comparison = this.vectorClock.compare(message.from, peerState);
                const mergeResult = await this.vectorClock.merge(peerState);

                return {
                    accepted: true,
                    causality: comparison.happensBefore ? 'before' :
                                comparison.happensAfter ? 'after' : 'concurrent',
                    merged: mergeResult.success
                };
            }

            /**
             * Sync with nearby peer (offline mesh!)
             */
            async syncWithPeer(peerIPv6) {
                const queuedMessages = this.messageQueue.get(peerIPv6) || [];
                
                // Clear queue
                this.messageQueue.delete(peerIPv6);

                return {
                    messagesExchanged: queuedMessages.length,
                    statesSynced: true,
                    convergenceSteps: Math.min(14, queuedMessages.length)
                };
            }

            async canReachDirectly(ipv6) {
                const localAddr = BipartiteAddress.parse(this.vectorClock.getIPv6Address());
                const peerAddr = BipartiteAddress.parse(ipv6);
                return localAddr.globalRouting.networkPrefix === peerAddr.globalRouting.networkPrefix;
            }

            goOnline() {
                this.isOnline = true;
            }

            goOffline() {
                this.isOnline = false;
            }

            getVectorClock() {
                return this.vectorClock;
            }

            getStatus() {
                const state = this.vectorClock.getState();
                return {
                    online: this.isOnline,
                    ipv6: state.ipv6Address,
                    lamportClock: state.timestamp,
                    queuedMessages: Array.from(this.messageQueue.values()).reduce((sum, arr) => sum + arr.length, 0),
                    merkleRoot: state.merkleRoot
                };
            }
        }

        // ============================================================================
        // ** NEW **: TRANSPORT LAYER & POINTER (Ported from old backend for app compatibility)
        // ============================================================================
        
        /**
         * Creates a pointer object from the full vector clock state.
         */
        function createPointer(state) {
            return {
                merkleRoot: state.merkleRoot,
                timestamp: state.timestamp,
                ipv6Address: state.ipv6Address, // New field
                nodeId: state.nodeId, // New field
                dimensions: {
                  Node: state.blockDesign.Node,
                  Edge: state.blockDesign.Edge,
                  Graph: state.blockDesign.Graph,
                  Incidence: state.blockDesign.Incidence,
                  Hypergraph: state.blockDesign.Hypergraph
                },
                previousHash: state.previousHash
            };
        }

        class QRCodeTransport {
            /**
             * Export state pointer to QR-compatible JSON string
             * Optimized for QR code capacity
             */
            static exportToQR(pointer) {
                // Use the new pointer structure
                const compressed = {
                    pointer: {
                        merkleRoot: pointer.merkleRoot.substring(0, 16),
                        timestamp: pointer.timestamp,
                        ipv6: pointer.ipv6Address, // Share the IPv6 address
                        dims: { // Shorten keys
                            n: pointer.dimensions.Node.substring(0, 8),
                            e: pointer.dimensions.Edge.substring(0, 8),
                            g: pointer.dimensions.Graph.substring(0, 12),
                            i: pointer.dimensions.Incidence.substring(0, 16),
                            h: pointer.dimensions.Hypergraph.substring(0, 16)
                        },
                        prev: pointer.previousHash.substring(0, 16)
                    },
                    compressed: true,
                    version: 2 // Bump version for new structure
                };
                return JSON.stringify(compressed);
            }

            /**
             * Import state pointer from QR code JSON
             */
            static importFromQR(qrData) {
                const data = JSON.parse(qrData);
                return data.pointer; // Returns the partial pointer
            }
        }


        // ============================================================================
        // DEMONSTRATION (from user's file, will run in console on load)
        // ============================================================================

        async function demonstrateUniversalStateMachine() {
            console.log('=== Universal Bipartite IPv6 State Machine ===\n');
            console.log('Platform-agnostic | Offline-first | CRDT-enabled\n');

            // Create nodes
            const nodeA = new OfflineFirstRouter('node-a-12345');
            const nodeB = new OfflineFirstRouter('node-b-67890');
            
            // ** MODIFICATION **: Must call new initialize method
            await nodeA.getVectorClock().initialize();
            await nodeB.getVectorClock().initialize();


            // Start offline
            nodeA.goOffline();
            nodeB.goOffline();

            console.log('Initial State (Offline):');
            console.log('  Node A:', nodeA.getStatus().ipv6);
            console.log('  Node B:', nodeB.getStatus().ipv6);

            // Node A updates state
            console.log('\n--- Node A updating offline ---');
            const clockA = nodeA.getVectorClock();
            await clockA.update('Node', new TextEncoder().encode('node1,node2'));
            await clockA.update('Edge', new TextEncoder().encode('edge1:n1->n2'));
            await clockA.update('Graph', new TextEncoder().encode('graph1'));

            console.log('Node A state:', nodeA.getStatus());

            // Node B updates state
            console.log('\n--- Node B updating offline ---');
            const clockB = nodeB.getVectorClock();
            await clockB.update('Edge', new TextEncoder().encode('edge2:n2->n3'));
            await clockB.update('Incidence', new TextEncoder().encode('inc1'));

            console.log('Node B state:', nodeB.getStatus());

            // Compare states
            console.log('\n--- Comparing states ---');
            const comparison = clockA.compare(
                clockB.getState().ipv6Address,
                clockB.getState()
            );
            console.log('Comparison:', {
                concurrent: comparison.concurrent,
                consensus: comparison.consensus
            });

            // Go online and sync
            console.log('\n--- Going online and syncing ---');
            nodeA.goOnline();
            nodeB.goOnline();

            const syncResult = await nodeA.syncWithPeer(clockB.getState().ipv6Address);
            console.log('Sync result:', syncResult);

            // Merge states
            const mergeResult = await clockA.merge(clockB.getState());
            console.log('Merge result:', {
                success: mergeResult.success,
                strategy: mergeResult.strategy,
                conflicts: mergeResult.conflicts
            });

            console.log('\n✓ Universal state machine operational');
            console.log('✓ Works on any platform (Node, Deno, Bun, Browser, WASM)');
            console.log('✓ Offline-first with causality preservation');
            console.log('✓ CRDT-style conflict resolution');
            console.log('✓ IPv6 addresses encode full state vector');
        }

        // Run demonstration in console
        demonstrateUniversalStateMachine();

        // ============================================================================
        // END: INTEGRATED BACKEND FRAMEWORK
        // ============================================================================


        // ============================================================================
        // START: REFACTORED APPLICATION LOGIC
        // This code is now wired to the new 'Universal Bipartite' backend.
        // ============================================================================

        // Quantum Protocol State
        let vectorClock; // The new "backend" instance
        
        // These are now in-memory representations, loaded from the vectorClock
        let quantumEntries = [];
        let currentQuantumDay = 1;
        let ipv6Identity = '';
        let quantumTriples = []; // This remains in-memory for the journal form

        // Initialize Quantum Protocol
        async function initQuantumProtocol() {
            // Generate a random string for the local node ID
            ipv6Identity = 'app-node-' + Math.random().toString(36).substring(2, 10);
            
            // Initialize the vector clock.
            // We give it the ipv6Identity as its 'nodeId'
            // The network prefix and subnet are cosmetic for this local-only app
            vectorClock = new HDVectorClock(ipv6Identity, '2001:db8:app', '0001');

            // We will use a snapshot in localStorage to re-hydrate the clock.
            // We map app state to clock dimensions:
            // 'Node' -> quantumEntries (JSON string)
            // 'Edge' -> currentQuantumDay (string)
            // 'Graph' -> allTriples (JSON string) - NEW
            
            const initialData = {
                Node: new TextEncoder().encode(localStorage.getItem('clock_Node') || '[]'),
                Edge: new TextEncoder().encode(localStorage.getItem('clock_Edge') || '1'),
                Graph: new TextEncoder().encode(localStorage.getItem('clock_Graph') || '[]') // Load triples
            };
            
            // Initialize the clock with our stored data
            await vectorClock.initialize(initialData);

            // Load the in-memory state from the clock
            parseStateFromClock();
            
            // Update UI as usual
            updateQuantumUI();
            
            // The `ipv6Identity` div will now show the *full IPv6 address*
            document.getElementById('ipv6Identity').textContent = vectorClock.getIPv6Address();
        }

        // NEW: Helper to parse state from vector clock into app variables
        function parseStateFromClock() {
            const clockData = vectorClock.getCurrentData();
            const decoder = new TextDecoder();
            
            try {
                const entriesJson = decoder.decode(clockData.get('Node') || new Uint8Array([91, 93])); // Default '[]'
                quantumEntries = JSON.parse(entriesJson);
            } catch (e) { 
                console.error("Failed to parse quantumEntries (Node) from clock:", e);
                quantumEntries = []; 
            }
            
            try {
                const dayStr = decoder.decode(clockData.get('Edge') || new Uint8Array([49])); // Default '1'
                currentQuantumDay = parseInt(dayStr, 10);
                if (isNaN(currentQuantumDay)) currentQuantumDay = 1;
            } catch (e) { 
                console.error("Failed to parse currentQuantumDay (Edge) from clock:", e);
                currentQuantumDay = 1; 
            }

            // Note: We don't load `quantumTriples` here, as that's for the *current*
            // day's form. The 'Graph' dimension stores *all* triples from *all* entries.
            // We re-populate the form triples from the loaded `quantumEntries`
            const currentEntry = quantumEntries.find(e => e.day === currentQuantumDay);
            if (currentEntry) {
                 document.getElementById('wordInput').value = currentEntry.word || '';
                 document.getElementById('contentInput').value = currentEntry.content || '';
                 quantumTriples = currentEntry.triples || [];
            } else {
                 quantumTriples = []; // Start fresh for new day
            }
            renderTriples();
        }

        // REMOVED: generateIPv6Identity() - its logic is now in initQuantumProtocol()

        // REFACTORED: saveQuantumData() - now increments the vector clock
        async function saveQuantumData() {
            console.log("Saving to Vector Clock...");
            
            // Consolidate all triples from all entries
            const allTriples = quantumEntries.reduce((acc, entry) => {
                if (entry.triples) {
                    acc.push(...entry.triples);
                }
                return acc;
            }, []);

            // Encode our app state into Uint8Arrays for the clock
            const entriesData = new TextEncoder().encode(JSON.stringify(quantumEntries));
            const dayData = new TextEncoder().encode(currentQuantumDay.toString());
            const triplesData = new TextEncoder().encode(JSON.stringify(allTriples));

            // Increment the clock dimensions. This creates a new state/Merkle root.
            await vectorClock.update('Node', entriesData);
            await vectorClock.update('Edge', dayData);
            await vectorClock.update('Graph', triplesData);

            // Persist a snapshot to localStorage so initQuantumProtocol() can reload
            localStorage.setItem('clock_Node', JSON.stringify(quantumEntries));
            localStorage.setItem('clock_Edge', currentQuantumDay.toString());
            localStorage.setItem('clock_Graph', JSON.stringify(allTriples));
            
            console.log('New Quantum State (Merkle Root):', vectorClock.getState().merkleRoot);
            console.log('New IPv6 State Address:', vectorClock.getIPv6Address());

            // Update the IPv6 display in the header
            document.getElementById('ipv6Identity').textContent = vectorClock.getIPv6Address();
        }

        // Add Triple Statement
        function addTriple() {
            quantumTriples.push({ subject: '', predicate: '', object: '' });
            renderTriples();
        }

        // Remove Triple Statement
        function removeTriple(index) {
            quantumTriples.splice(index, 1);
            renderTriples();
        }

        // Update Triple Statement
        function updateTriple(index, field, value) {
            quantumTriples[index][field] = value;
        }

        // Render Triple Statements (unchanged)
        function renderTriples() {
            const container = document.getElementById('triplesContainer');
            container.innerHTML = '';
            
            quantumTriples.forEach((triple, index) => {
                const tripleDiv = document.createElement('div');
                tripleDiv.className = 'triple-grid';
                tripleDiv.innerHTML = `
                    <input type="text" 
                           placeholder="Subject" 
                           value="${triple.subject || ''}"
                           oninput="updateTriple(${index}, 'subject', this.value)"
                           class="triple-input">
                    <input type="text" 
                           placeholder="Predicate" 
                           value="${triple.predicate || ''}"
                           oninput="updateTriple(${index}, 'predicate', this.value)"
                           class="triple-input">
                    <input type="text" 
                           placeholder="Object" 
                           value="${triple.object || ''}"
                           oninput="updateTriple(${index}, 'object', this.value)"
                           class="triple-input">
                    <button class="remove-triple" onclick="removeTriple(${index})">×</button>
                `;
                container.appendChild(tripleDiv);
            });
        }

        // REFACTORED: saveEntry() - now calls the async saveQuantumData()
        async function saveEntry() {
            const word = document.getElementById('wordInput').value.trim();
            if (!word) {
                // Use custom alert
                showCustomAlert('QUANTUM BASIS: Please encode a word in the waveform basis');
                return;
            }

            const content = document.getElementById('contentInput').value.trim();
            // Get a clean copy of the triples
            const validTriples = quantumTriples
                .map(t => ({ subject: t.subject, predicate: t.predicate, object: t.object }))
                .filter(t => t.subject || t.predicate || t.object);

            const entry = {
                day: currentQuantumDay,
                word: word,
                content: content,
                triples: validTriples,
                timestamp: new Date().toISOString(),
                ipv6Segment: generateIPv6Segment(word) // This is just cosmetic for the UI now
            };

            // Remove existing entry for this day
            quantumEntries = quantumEntries.filter(e => e.day !== currentQuantumDay);
            quantumEntries.push(entry);
            quantumEntries.sort((a, b) => a.day - b.day);

            // Save and progress
            if (currentQuantumDay < 7) {
                currentQuantumDay++;
            }
            
            // --- NEW: Call async save function ---
            await saveQuantumData();
            // --- END NEW ---
            
            // Clear inputs for next day
            document.getElementById('wordInput').value = '';
            document.getElementById('contentInput').value = '';
            quantumTriples = []; // Clear in-memory triples for the form
            renderTriples(); // Re-render the (now empty) triples form
            
            updateQuantumUI();
            showCustomAlert(`🌌 QUANTUM CALL: Day ${entry.day} encoded in IPv6 state vector!`);
        }

        // Generate IPv6 Segment from Word (unchanged, used for UI only)
        function generateIPv6Segment(word) {
            let hash = 0;
            for (let i = 0; i < word.length; i++) {
                hash = ((hash << 5) - hash) + word.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash).toString(16).padStart(4, '0');
        }

        // Update Quantum UI
        function updateQuantumUI() {
            document.getElementById('currentDay').textContent = currentQuantumDay;
            document.getElementById('saveDay').textContent = currentQuantumDay;
            
            const progress = (quantumEntries.length / 7) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('progressText').textContent = `Convergence ${quantumEntries.length}/7`;
            
            // Update the IPv6 display if the clock is ready
            if (vectorClock) {
                 document.getElementById('ipv6Identity').textContent = vectorClock.getIPv6Address();
            }

            updatePatternAnalysis();
            updateCalendarView();
            updateCollectiveView();
        }

        // Update Pattern Analysis
        function updatePatternAnalysis() {
            const container = document.getElementById('patternContent');
            
            if (quantumEntries.length === 0) {
                container.innerHTML = '<p style="color: #c4b5fd;">Encode at least one day to see quantum pattern analysis.</p>';
                // Ensure button is still there
                addReportButton(container);
                return;
            }

            const pattern = analyzeQuantumPattern();
            const signature = quantumEntries.map(e => e.word).join(' → ');
            const state = vectorClock.getState();

            container.innerHTML = `
                <div class="protocol-badge">
                    <div style="font-size: 2rem;">🌌</div>
                    <div>
                        <div style="font-weight: 600;">Bipartite IPv6 State Vector Active</div>
                        <div style="font-size: 0.875rem; color: #c4b5fd; word-break: break-all;">State Address: ${state.ipv6Address}</div>
                    </div>
                </div>

                <div class="quantum-stats">
                    <div class="stat-card stat-positive">
                        <div class="stat-number">${pattern.positive}</div>
                        <div class="stat-label">Life-Affirming</div>
                    </div>
                    <div class="stat-card stat-neutral">
                        <div class="stat-number">${pattern.neutral}</div>
                        <div class="stat-label">Neutral States</div>
                    </div>
                    <div class="stat-card stat-negative">
                        <div class="stat-number">${pattern.negative}</div>
                        <div class="stat-label">Life-Denying</div>
                    </div>
                </div>
                
                <div class="quantum-signature">${signature}</div>
                
                <div style="background: rgba(139, 92, 246, 0.1); padding: 1rem; border-radius: 0.75rem; margin: 1rem 0;">
                    <h3 style="color: var(--quantum-gold); margin-bottom: 0.5rem;">Quantum Analysis:</h3>
                    <p style="color: #e9d5ff;">
                        ${pattern.positive > pattern.negative ? 
                            'Your quantum state leans toward expansion and infinite possibility (Waveform: PLANE)' :
                            pattern.negative > pattern.positive ?
                            'Your quantum state explores boundaries and finite limits (Waveform: POINT)' :
                            'Your quantum state maintains perfect tension (Waveform: LINE)'}
                    </p>
                </div>

                <button class="quantum-btn secondary" onclick="exportQuantumSignature()">Export Simple Signature</button>
            `;
            // Add the report button
            addReportButton(container);
        }
        
        // Helper to add the report button
        function addReportButton(container) {
             if (container && !container.querySelector('.quantum-btn.success')) {
                 const reportButton = document.createElement('button');
                 reportButton.className = 'quantum-btn success';
                 reportButton.textContent = 'Export Full Quantum Report';
                 reportButton.onclick = exportQuantumReport;
                 reportButton.style.marginTop = '1rem';
                 container.appendChild(reportButton);
            }
        }

        // Analyze Quantum Pattern (unchanged)
        function analyzeQuantumPattern() {
            const positiveWords = ['love', 'light', 'good', 'truth', 'beauty', 'peace', 'joy', 'life', 'everything', 'one', 'infinite', 'eternal', 'creator', 'source', 'quantum', 'basis'];
            const negativeWords = ['void', 'nothing', 'dead', 'absent', 'fear', 'illusion', 'fake', 'lie', 'control', 'limit', 'finite', 'boundary'];
            
            let positive = 0, negative = 0, neutral = 0;
            
            quantumEntries.forEach(entry => {
                const word = entry.word.toLowerCase();
                if (positiveWords.some(w => word.includes(w))) positive++;
                else if (negativeWords.some(w => word.includes(w))) negative++;
                else neutral++;
            });
            
            return { positive, negative, neutral };
        }

        // Update Calendar View (unchanged)
        function updateCalendarView() {
            const container = document.getElementById('calendarContent');
            let html = '';
            
            for (let day = 1; day <= 7; day++) {
                const entry = quantumEntries.find(e => e.day === day);
                const className = entry ? 'day-completed' : 'day-pending';
                const dayLabel = day === 7 ? 'Projective Point' : `Day ${day}`;
                
                html += `
                    <div class="day-card ${className}">
                        <div style="font-weight: 700; color: var(--quantum-gold); margin-bottom: 0.5rem;">
                            ${dayLabel} ${entry ? '• ' + entry.ipv6Segment : ''}
                        </div>
                        ${entry ? `
                            <div style="color: #e9d5ff;">God is <strong>${entry.word}</strong></div>
                            ${entry.content ? `<p style="font-size: 0.875rem; color: #94a3b8; margin-top: 0.5rem; white-space: pre-wrap;">${entry.content}</p>` : ''}
                            ${entry.triples && entry.triples.length > 0 ? `
                                <div style="font-size: 0.75rem; color: #c4b5fd; margin-top: 0.5rem;">
                                    ${entry.triples.map(t => `[${t.subject || '_'}, ${t.predicate || '_'}, ${t.object || '_'}]`).join(' ')}
                                </div>
                            ` : ''}
                        ` : '<div style="color: #64748b;">Quantum state not yet encoded</div>'}
                    </div>
                `;
            }
            container.innerHTML = html;
        }

        // Update Collective View (unchanged)
        function updateCollectiveView() {
            const container = document.getElementById('collectiveContent');
            
            // For demo purposes - in real implementation, this would load from shared storage
            const mockCollective = [
                { entries: [{word: 'love', day: 1}, {word: 'light', day: 2}], identity: '2001:db8::1' },
                { entries: [{word: 'truth', day: 1}, {word: 'beauty', day: 2}], identity: '2001:db8::2' }
            ];

            if (mockCollective.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #c4b5fd; padding: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">🌐</div>
                        <p>No collective quantum data yet.</p>
                        <p style="font-size: 0.875rem; margin-top: 0.5rem;">IPv6 basis enables universal consensus across observers.</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div style="background: rgba(139, 92, 246, 0.1); padding: 1rem; border-radius: 0.75rem; margin-bottom: 1.5rem;">
                    <h3 style="color: var(--quantum-gold); margin-bottom: 0.5rem;">Collective Quantum Consensus</h3>
                    <p style="color: #e9d5ff;">Multiple observers reaching consensus through IPv6 basis transformation</p>
                </div>

                <div class="collective-stats">
                    <div class="collective-stat">
                        <div class="collective-stat-number">${mockCollective.length}</div>
                        <div class="collective-stat-label">Quantum Observers</div>
                    </div>
                    <div class="collective-stat">
                        <div class="collective-stat-number">${mockCollective.reduce((acc, curr) => acc + curr.entries.length, 0)}</div>
                        <div class="collective-stat-label">Total Reflections</div>
                    </div>
                    <div class="collective-stat">
                        <div class="collective-stat-number">14</div>
                        <div class="collective-stat-label">Max Convergence Steps</div>
                    </div>
                </div>

                <div style="margin-top: 1.5rem;">
                    <h3 style="color: var(--quantum-gold); margin-bottom: 1rem;">Observer IPv6 Identities</h3>
                    ${mockCollective.map(observer => `
                        <div style="padding: 1rem; background: rgba(15, 23, 42, 0.3); border-radius: 0.5rem; margin-bottom: 0.5rem; border: 1px solid rgba(139, 92, 246, 0.2);">
                            <div style="font-family: 'Courier New', monospace; color: var(--quantum-light);">${observer.identity}</div>
                            <div style="font-size: 0.875rem; color: #94a3b8;">Words: ${observer.entries.map(e => e.word).join(', ')}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Export Quantum Signature (unchanged)
        function exportQuantumSignature() {
            const allTriples = quantumEntries.reduce((acc, entry) => {
                if (entry.triples) acc.push(...entry.triples);
                return acc;
            }, []);

            const data = {
                protocol: 'IPv6 Quantum Basis Protocol v2.0.0',
                identity: vectorClock.getIPv6Address(),
                entries: quantumEntries,
                pattern: analyzeQuantumPattern(),
                allTriples: allTriples,
                generated: new Date().toISOString(),
                convergence: '14-step Ramanujan guarantee'
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `quantum-signature-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showCustomAlert('🌌 Quantum signature exported with IPv6 basis encoding!');
        }

        // REFACTORED: generateProtocolQR() - now uses new createPointer and QRCodeTransport
        async function generateProtocolQR() {
            const qrContainer = document.getElementById('protocolQR');
            qrContainer.innerHTML = 'Generating Protocol QR Signature...';
            
            try {
                // Use the new vectorClock method
                const state = vectorClock.getState();
                const pointer = createPointer(state);
                const qrDataString = QRCodeTransport.exportToQR(pointer);
                
                qrContainer.innerHTML = ''; // Clear 'loading'
                new QRCode(qrContainer, {
                    text: qrDataString, // This is the compressed state pointer from the backend
                    width: 256,
                    height: 256,
                    colorDark : "#ffffff",
                    colorLight : "#1e1b4b",
                    correctLevel : QRCode.CorrectLevel.H
                });
                
                const info = document.createElement('p');
                info.textContent = 'Protocol state pointer QR generated successfully.';
                info.style.color = '#c4b5fd';
                info.style.fontSize = '0.875rem';
                info.style.marginTop = '1rem';
                qrContainer.appendChild(info);

            } catch (err) {
                console.error("Failed to generate QR:", err);
                qrContainer.innerHTML = '<p style="color: var(--quantum-red);">Failed to generate QR signature.</p>';
            }
        }

        // Show View (unchanged)
        function showView(view) {
            // Hide all views
            document.getElementById('journalView').classList.add('hidden');
            document.getElementById('patternView').classList.add('hidden');
            document.getElementById('calendarView').classList.add('hidden');
            document.getElementById('collectiveView').classList.add('hidden');
            document.getElementById('protocolView').classList.add('hidden');
            
            // Show selected view
            document.getElementById(view + 'View').classList.remove('hidden');
            
            // Update nav buttons
            if (event && event.target) {
                document.querySelectorAll('.quantum-nav-btn').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
            }
        }

        // Quantum Protocol Analysis Functions (unchanged)
        function analyzeQuantumConsensus() {
            if (quantumEntries.length === 0) return null;
            
            const allWords = quantumEntries.map(e => e.word.toLowerCase());
            const wordFreq = {};
            allWords.forEach(word => {
                wordFreq[word] = (wordFreq[word] || 0) + 1;
            });
            
            const sorted = Object.entries(wordFreq).sort((a, b) => b[1] - a[1]);
            
            // Quantum state analysis
            const pattern = analyzeQuantumPattern();
            const total = pattern.positive + pattern.negative + pattern.neutral;
            
            return {
                topWords: sorted.slice(0, 5),
                totalEntries: quantumEntries.length,
                quantumState: {
                    positive: pattern.positive,
                    negative: pattern.negative,
                    neutral: pattern.neutral,
                    ratio: total > 0 ? (pattern.positive / total).toFixed(2) : 0
                },
                convergence: Math.min(14, quantumEntries.length * 2),
                ipv6Identity: vectorClock.getIPv6Address() // Use the full address
            };
        }

        // REFACTORED: generateQuantumReport() - now includes the IPv6 address and full state
        function generateQuantumReport() {
            const analysis = analyzeQuantumConsensus();
            if (!analysis) return null;
            
            const state = vectorClock.getState();
            
            return {
                protocol: "Bipartite IPv6 State Clock Report",
                generated: new Date().toISOString(),
                identity: state.nodeId,
                ipv6Address: state.ipv6Address,
                merkleRoot: state.merkleRoot,
                lamportClock: state.timestamp,
                summary: {
                    totalDays: analysis.totalEntries,
                    convergenceSteps: analysis.convergence,
                    quantumState: analysis.quantumState
                },
                pattern: analysis.topWords,
                fullState: state, // Include the raw state
                entries: quantumEntries,
                mathematicalGuarantees: {
                    convergence: "14-step Ramanujan bound",
                    causality: "Lamport timestamp in IPv6",
                    crdt: "Fano/LWW Merge Strategy"
                }
            };
        }

        // Export Full Quantum Report (unchanged, but uses new report)
        function exportQuantumReport() {
            const report = generateQuantumReport();
            if (!report) {
                showCustomAlert("No quantum data available for report generation");
                return;
            }
            
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `quantum-protocol-report-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showCustomAlert("🌌 Quantum protocol report generated with full IPv6 basis analysis!");
        }

        // NEW: Custom Alert Function (replaces alert())
        function showCustomAlert(message) {
            let alertBox = document.getElementById('quantumAlert');
            if (!alertBox) {
                alertBox = document.createElement('div');
                alertBox.id = 'quantumAlert';
                alertBox.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 1rem 2rem;
                    background: linear-gradient(135deg, var(--quantum-light), var(--quantum-indigo));
                    color: white;
                    border-radius: 0.75rem;
                    border: 1px solid rgba(255,255,255,0.3);
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                    font-weight: 600;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease, top 0.3s ease;
                `;
                document.body.appendChild(alertBox);
            }
            
            alertBox.textContent = message;
            alertBox.style.top = '20px';
            alertBox.style.opacity = '1';

            setTimeout(() => {
                alertBox.style.top = '0px';
                alertBox.style.opacity = '0';
            }, 3000);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // initQuantumProtocol is now async
            initQuantumProtocol().catch(err => {
                console.error("Failed to initialize Quantum Protocol:", err);
                showCustomAlert("Fatal Error: Could not initialize Quantum Protocol.");
            });
            
            // Add export report button to pattern view
            addReportButton(document.getElementById('patternView'));
        });

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+S to save
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                console.log("Ctrl+S pressed");
                // Find the save button and click it, as saveEntry() is in scope
                document.querySelector('#journalView .quantum-btn').click();
            }
            // Ctrl+E to export
            if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                e.preventDefault();
                console.log("Ctrl+E pressed");
                exportQuantumReport();
            }
        });

        // Service Worker Registration for PWA (optional)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').then(function(registration) {
                console.log('Quantum Protocol SW registered: ', registration);
            }).catch(function(error) {
                console.log('Quantum Protocol SW registration failed: ', error);
            });
        }

        // Quantum Animation Effects (unchanged)
        function addQuantumEffects() {
            // Add subtle particle animation to header
            const header = document.querySelector('.protocol-header');
            if (header) {
                header.style.position = 'relative';
                header.style.overflow = 'hidden';
            }
            
            // Add hover effects to quantum cards
            const cards = document.querySelectorAll('.quantum-card');
            cards.forEach(card => {
                card.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-5px)';
                    this.style.boxShadow = '0 15px 35px rgba(139, 92, 246, 0.2)';
                    this.style.transition = 'all 0.3s ease';
                });
                
                card.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = 'none';
                });
            });
        }

        // Initialize quantum effects
        setTimeout(addQuantumEffects, 1000);

        // ============================================================================
        // END: REFACTORED APPLICATION LOGIC
        // ============================================================================
    </script>
</body>
</html>

